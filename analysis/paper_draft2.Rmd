---
title: "Bayesian Detection of Bias in Peremptory Challenges Using Historical Strike Data"
date: "`r Sys.Date()`"
author:
  - Sachin S. Pandya
#    orcid_id: 0000-0001-7387-1307
  - Xiaomeng Li
  - Timothy E. Moore
#    orcid_id: 0000-0002-9576-0517
#output: distill::distill_article
output: pdf_document
bibliography: references.bib
abstract: |
  US law bars using peremptory strikes during jury selection because of prospective juror race, ethnicity, gender, or membership in certain other cognizable classes. Here, we propose a Bayesian approach for detecting such illegal bias. We show how to use historical data on an attorney's use of peremptory strikes in past cases to estimate, in a current trial, how likely an attorney has struck prospective jurors because of cognizable-class membership. We also use of a _power prior_ to ajust the weight of such historical data in the analysis. We show the utility of our model on simulated data. Finally, we extend our approach by presenting a prototype software application to be used to detect bias in peremptory-challenge in real time during jury-selection. We demonstrate the app using actual historical strike data from a convenience sample of cases from the federal district court of Connecticut from YYYY to YYYY.

---

```{r setup, include=FALSE}

library(ggplot2)
library(dplyr)

knitr::opts_chunk$set(echo = FALSE, warnings = FALSE, message = FALSE)

```

# Introduction

In the US, individuals selected for jury-service appear in court as scheduled and are questioned by the parties' attorneys and the trial judge. During this process, a prospective juror, if not excused by the trial judge for cause, may still be dismissed if a party's attorney uses one of their limited number of peremptory challenges against them. By asserting a peremptory challenge, a party can declare a prospective juror ineligible ("strikes" that juror) for a seat on the jury without the burden of explaining why.

Since the US Supreme Court's decision in _Batson v. Kentucky_ [-@batson1986], a party violates the Equal Protection Clause of the US Constitution by using peremptory challenges if motivated by the prospective jurors' race, ethnicity, gender, or membership in another cognizable class. The party bringing a _Batson_ challenge bears the burden of proving such illegal bias [@LaFave2020, sec. 22.3]. For similar challenges under State law, a few States accept proof not of motive but only that an "objective observer" would find that race, ethnicity or another cognizable-class membership was a "factor" in that party's use of strikes [e.g., Wash. R. 37(e)]. Peremptory-challenge procedure, and thus the task of proving illegal bias, varies not only by State, but also by court, including the number of peremptory challenges assigned to each side and the order in which each party uses those strikes [@nscs-jury2018; @Williams2017]. 

In any case, evidence supporting such challenges may include aggregate data on peremptory challenges in past cases. For example, in a State criminal case, evidence for a _Batson_ challenge can include the "relevant history of the State's peremptory strikes in past cases." [@flowers2019, 2243]. Prior work on statistical methods for _Batson_ challenges, however, has largely focused on strike data from a single case [e.g. @Barrett2007; @Gastwirth2016; @Kadane2018; @Kadane2018a], perhaps because jury-selection records are often not readily available [@Grosso2017; @Wright2018] and otherwise require painstaking effort to collect [e.g., @APM2018].

When collecting strike data in multiple trials, prior studies have aggregated strikes across trials, reported the observed difference in strike rates by race or gender, and tested for the probability of observing a non-zero difference in strike rates by race or gender, given repeated sampling from a hypothetical population of peremptory strikes with zero such difference. [@Eisenberg2017, 334-339; see also @Gastwirth2014; @Gastwirth2013]. Prior studies have also modeled how much a prospective juror's race affected the odds of being struck [e.g., @Baldus2001]. For different approaches to the same historical strike data from from Mississippi's Fifth Circuit Court District (1992-2017), see @Craft2018a (logistic regression); @DeCamp2020 (propensity score matching); and @Dunn2021 (optimal feature selection, optimal classification trees).

In this paper, we take a Bayesian approach to _Batson_ challenges [@Kadane2018] and extend it to incorporate historical strike data. In this approach, we specify a model of the peremptory-strike process in the court of interest that includes bias parameter $b$, to which we assign an initial prior distribution. Then, we use an attorney's strike data from past trials, as generated by the same peremptory-strike process, to estimate a posterior distribution for $b$. In so doing, we use the _power prior_ [@Ibrahim2000; @Ibrahim2015] to control how much the strike history from past cases affects the posterior distribution of the bias parameter $b$.  Finally, we use that posterior distribution as the prior for $b$ in the present case and update the posterior based on data on the target attorney's strikes in that present case.

Here, we demonstrate this approach, including the results of simulation studies to test model performance. Then, we present a software prototype that would let an attorney use the same approach in using historical strike data to help detect bias in peremptory-challenge use in real time during jury selection. 

# Method

## Statistical Procedure

Following @Kadane2018 and @Barrett2007, we model a "struck-jury" peremptory-challenge process in which each party strikes prospective jurors in an alternating sequence. Under the "struck jury" procedure, the trial judge rules on all challenges for cause before the parties exercise any peremptories, so that the number of potential jurors who remain is the sum of number of seats on the jury (plus alternates, if any) and the number of peremptory challenges allotted to both sides. Then, the parties exercise their strikes on those potential jurors, either submitting strikes simultaneously or in an alternating sequence. Once all strikes are used or waived, the jurors are seated based on the order in which they were selected or at random. 

Accordingly, for any given case $i$ in which jury selection occurs, let $j$ denote a peremptory strike used, and let $\delta_{ij}$ denote whether or not a party used that strike on a person who belongs to a "cognizable class". If "race" is the bias type of interest, the cognizable class is racial minority jurors ($\delta_{ij} =1$, 0 for White jurors).  If "gender" is the bias of interest, the cognizable class is female jurors ($\delta_{ij} = 1$, 0 for male jurors). In turn, let $c_{ij}$ denote the number of cognizable class members subject to strike; and $m_{ij}$ denote the number of cognizable class non-members subject to strike, such that $c_{ij}+m_{ij}$ is the total number of jurors potentially subject to strike. If there is no bias, the probability is $\frac{c_{ij}}{c_{ij}+m_{ij}}$ for striking a cognizable class member, and $1-\frac{c_{ij}}{c_{ij}+m_{ij}}$ for striking someone who does not belong to that class.

By adding one parameter $w$, we can measure the _bias_ by different values of $w$ by defining the probability of a cognizable class member being struck to be $\frac{wc_{ij}}{wc_{ij}+m_{ij}}$. To avoid making the weight of the non-cognizable class be the reciprocal of the weight of cognizable class, let $b = log(w)$. 

Accordingly, for any given value of the bias parameter $b$, the probability of strike of a member from either class, or $Pr(\delta_{ij})$, is shown in equation \@ref(eq:model1)

$$
Pr(\delta_{ij} | b) = 
\begin{cases}
  \frac{(e^b)c_{ij}}{(e^b)c_{ij}+m_{ij}} & \text{for }\delta_{ij}=1\\    
  \frac{m_{ij}}{(e^b)c_{ij}+m_{ij}} & \text{for }\delta_{ij}=0  
\end{cases}
$$

This is equivalent to

$$Pr(\delta_{ij}| b) = (\frac{(e^b)c_{ij}}{(e^b)c_{ij}+m_{ij}})^{\delta_{ij}} (\frac{m_{ij}}{(e^b)c_{ij}+m_{ij}})^{1-\delta_{ij}}$$

Given the strike data we have, i.e., $\delta_{ij}$, $c_{ij}$, and $m_{ij}$, by estimating the value of $b$, we can measure bias when a party is striking potential jurors. If $b = 0$, there is no bias, and the probability of strike is simply a function of the share of cognizable members (non-members) in the pool of prospective jurors that could be struck. If $b>0$, we infer that the the party has bias favoring a strike against a juror falling within the cognizable class (e.g., the juror is a racial minority). Where $b<0$, the party has a preference for a juror within the cognizable class. 

The likelihood function of $b$ is shown in equation \@ref(eq:model2)

$$ 
L(b|\delta) = \prod_{i=1}^{n_i} \prod_{j=1}^{n_j}(\frac{(e^b)c_{ij}}{(e^b)c_{ij}+m_{ij}})^{\delta_{ij}} (\frac{m_{ij}}{(e^b)c_{ij}+m_{ij}})^{1-\delta_{ij}}
$$
where $n_{i}$ is the total number of jury selections (trials); and $n_j$ is the total number of peremptory strikes. 

## Incorporating historical strike data

We incorporate the historical data on strikes in past cases and allow for adjustment of the weight of that historical information on the posterior distribution of the bias parameter. To do this, we introduce the power prior:

$$\pi(b|D_0,a_0) \propto L(b|D_0)^{a_0}\pi_0(b)$$
where $0 \le a_0 \le 1$ is the parameter controlling the weight of the historical information; $D_0$ is the observed historical data; $L(b|D_0)$ is the likelihood function of $b$ given the historical data; and $\pi_0(b)$ is the initial prior before the historical data is observed. 


In this paper, we assume a normal prior for $\pi_0(b)$ with mean 0 and standard deviation 2. This departs from @Kadane2018, who assigned $b$ a prior of $Unif(-6,6)$. We assume that the law assigning the burden of proof for _Batson_ challenges entails a weakly-informative prior. For our initial prior of $N(0,2)$, we let $\mu = 0$, because the law assigns the burden of proof in a _Batson_ challenge to the party bringing the challenge as well as the initial burden of producing some relevant evidence of illegal bias (the _Batson_ prima facie case). Thus, if that challenging party in fact produces no relevant evidence of illegal bias, the law requires a trial judge to reject the challenge as unproven. This is tantamount to treating zero as the most-likely value of the bias parameter, absent any data.

Moreover, we take that law as requiring, absent any data, the assumption that higher degrees of illegal bias (preference) are less likely than lower degrees of bias (preference). By using a normal (Gaussian) distribution with $\sigma = 2$, we encode this assumption by making values of the bias parameter less likely as they move further from zero and by making very unlikely values any value of $b$ greater than two standard deviations from the mean. 

After including the historical information through the power prior, the posterior distribution of $b$  is proportional to the product of likelihood function of $b$ and the power prior of $b$ as shown in \@ref(eq:model4) 

$$
L(b|\delta) = L(b|\delta)(L(b|\delta_0))^{a_0}\exp(-\frac{b^2}{8})
$$

where 

$$L(b|\delta_0) = \prod_{i=1}^{n_{0i}} \prod_{j=1}^{n_{0j}}(\frac{(e^b)c_{0ij}}{(e^b)c_{0ij}+m_{0ij}})^{\delta_{0ij}} (\frac{m_{0ij}}{(e^b)c_{0ij}+m_{0ij}})^{1-\delta_{0ij}}$$

is the likelihood function of $b$ given historical data. $n_{0i}$ is the total number of jury selections in the historical data, and $n_{0j}$ is the total number of peremptory strikes in the historical data. $\delta_{0ij}$ denote whether or not a party used that strike on a person who belongs to a "cognizable class" in the historical trials. 

The posterior distribution does not have a closed form.  Accordingly, we used the Metropolis-Hasting algorithm to sample $b$ from the posterior distribution. To measure convergence, we used traceplots, the Gelman-Rubin convergence diagnostic and Gewekeâ€™s diagnostics [@Gelman1992; @Gelman1998;@Geweke1992]. 

## Model Performance on Simulated Data

We conducted a simulation study to measure model performance under different values of the bias parameter $b$ and different amounts and kinds of historical information. 

To do this, we generated strike data for a current trial using seven different values of the bias parameter ("current" $b = {-3,-2,-1,0,1,2,3}$. As introduced above, $b>0$ ($b<0$) represents a bias against (preference) for a prospective juror within (outside) the cognizable class, while $b=0$ denotes neither bias or preference. A greater absolute value of $b$ represents greater bias against or preference for the cognizable class.

We also generated historical strike data of three sizes (same, double, and triple the size of current data, i.e., data on one previous trial, two previous trials) using seven different values of the bias parameter for generating that historical data ( _historical_ $b = {-3,-2,-1,0,1,2,3}$).

We let historical $b$ differ from current $b$ (our parameter of interest) to simulate noise associated with historical strike data that is incomplete not at random. Alternatively, this difference simulates a real difference in the bias parameter that depends on a feature that the current trial has but that all the past trials in the historical data do not. To illustrate, suppose prosecutor with a bias value conditional on defendant race: $b > 0$ if the criminal defendant is Black, $b = 0$ if not. If our historical strike data contains only in cases with non-Black defendants, accounting for that historical data may lead us to underestimate prosecutor's bias $b$ in the current case with a Black defendant.

Because we use the power prior, we can control the weight that we put on historical data by modifying the weight parameter $a$. If $a = 1$, the historical strike data is equally weighted with the present data on strikes. If $a < 1$, the historical data matters proportionally less. We can assign $a < 1$ to evaluate how sensitive the posterior of the bias parameter is to the historical data on strikes. Accordingly, in the simulation study, we tried different values of the weight parameter $a = (0.1,0.3,0.5,0.7,1)$ to show how that parameter affected modeling accuracy.

We considered 735 scenarios in total, i.e., the combination of 7 different bias parameters of current data and of historical data, 3 different amounts of historical data and 5 different values of the power prior weight parameter $a$. For each scenario, we generated 1000 datasets and fit the model on those datasets. We recorded the mean value of the posterior mean and credible intervals of one thousand model fits for each scenario.

In turn, for three credible interval levels (80\%, 90\% and 95\%), we recorded the coverage rates, i.e., the proportion of times those intervals actually contained the true value of the (current) bias parameter $b$. For instance, a 90\% coverage rate means that in 900 of 1000 model fits, a given credible interval contained what we fixed as the value of current $b$. Put another way, if we set $b>0$, we calculate the proportion of the 90\% credible intervals that lie to the right of zero among the 1000 model fits. 

The following figures depict the coverage rates of $b$ under the 80\% credible interval (Figure \@ref(fig:b80)), under the 90\% credible interval (Figure \@ref(fig:b90)), and under the 95\% credible interval (Figure \@ref(fig:b95)).

```{r b80, fig.cap="80% credible interval"}

# simulated data via "noseq_simulation.R" script

load_path <- here::here("data-sim","sim_resultc.csv")

sims <- readr::read_csv(load_path)
sims$a.f <- as.factor(sims$a)

sims$sig <- ifelse(sims$L80 <0 & sims$U80 >0 , "ns", 1) 
sims$sig <- ifelse(sims$L80 >0 & sims$U80 >0 , "pos", sims$sig) 
sims$sig <- ifelse(sims$L80 <0 & sims$U80 <0 , "neg", sims$sig) 

sims$sig.n <- 0
sims$sig.n <- ifelse(sims$sig=="pos", 1, sims$sig.n)
sims$sig.n <- ifelse(sims$sig=="neg", 1, sims$sig.n)

library(ggplot2)

p80 <- ggplot()+
  geom_tile(data = sims, aes(x = d, y = d_h,
                        fill = as.factor(sig.n)),
            color="black")+
  facet_grid(h~a, labeller = label_both)+
  # scale_fill_gradient2(expression(hat(d)), 
  #                      low = "darkred", mid = "white", 
  #                      high = "blue", 
  #                      breaks = c(-3, -2, -1, 0, 1, 2, 3), 
  #                      limits = c(-3.2, 3.2),
  #         labels = c("Neg bias", "", "", "NS","", "", "Bias"))+
  scale_x_continuous(breaks = c(-3:3), expand = c(0,0))+
  scale_y_continuous(breaks = c(-3:3), expand = c(0,0))+
  xlab("Current b")+
  ylab("Historical b")+
  scale_fill_manual(values = c("white", "blue"))+
  coord_equal() +
  theme_minimal() +
  labs(fill = "coverage") +
  theme(axis.text = element_text(size =10), 
        #axis.title = element_text(size = 16), 
        #legend.title.align = 0.05, 
        #legend.title = element_text(size = 16), 
        legend.text = element_text(size = 14))
p80

```


```{r b90, fig.cap="90% credible interval"}

# INSERT simulation and plot code
sims$a.f <- as.factor(sims$a)
sims$sig <- ifelse(sims$L90 <0 & sims$U90 >0 , "ns", 1) 
sims$sig <- ifelse(sims$L90 >0 & sims$U90 >0 , 
                                    "pos", sims$sig) 
sims$sig <- ifelse(sims$L90 <0 & sims$U90 <0 , 
                                    "neg", sims$sig) 
sims$sig.n <- 0
sims$sig.n <- ifelse(sims$sig=="pos", 1, sims$sig.n)
sims$sig.n <- ifelse(sims$sig=="neg", 1, sims$sig.n)

p90 <- ggplot()+
  geom_tile(data = sims, aes(x = d, y = d_h,
                        fill = as.factor(sig.n)),
            color="black")+
  facet_grid(h~a, labeller = label_both)+
  scale_x_continuous(breaks = c(-3:3), expand = c(0,0))+
  scale_y_continuous(breaks = c(-3:3), expand = c(0,0))+
  xlab("Current b")+
  ylab("Historical b")+
  scale_fill_manual(values = c("white", "blue"))+
  coord_equal()+
  theme_minimal()+
  labs(fill = "coverage") +
  theme(axis.text = element_text(size =10), 
        axis.title = element_text(size = 16),
        legend.title.align = 0.05, 
        legend.title = element_text(size = 16), 
        legend.text = element_text(size = 14))
p90

```

```{r b95, fig.cap="95% credible interval"}

# INSERT simulation and plot code
sims$a.f <- as.factor(sims$a)
sims$sig <- ifelse(sims$L95 <0 & sims$U95 >0 , "ns", 1) 
sims$sig <- ifelse(sims$L95 >0 & sims$U95 >0 , 
                                    "pos", sims$sig) 
sims$sig <- ifelse(sims$L95 <0 & sims$U95 <0 , 
                                    "neg", sims$sig) 
sims$sig.n <- 0
sims$sig.n <- ifelse(sims$sig=="pos", 1, sims$sig.n)
sims$sig.n <- ifelse(sims$sig=="neg", 1, sims$sig.n)

p<- ggplot()+
  geom_tile(data = sims, aes(x = d, y = d_h,
                        fill = as.factor(sig.n)),
            color="black")+
  facet_grid(h~a, labeller = label_both)+
  scale_x_continuous(breaks = c(-3:3), expand = c(0,0))+
  scale_y_continuous(breaks = c(-3:3), expand = c(0,0))+
  xlab("Current b")+
  ylab("Historical b")+
  scale_fill_manual(values = c("white", "blue"))+
  coord_equal()+
  theme_classic()+  
  labs(fill = "coverage") +
  theme(axis.text = element_text(size =10), 
        axis.title = element_text(size = 16), 
        legend.title.align = 0.05, 
        legend.title = element_text(size = 16), 
        legend.text = element_text(size = 14))

p90

```

In these figures, _historical b_ denotes the bias parameter for the generated historical data, and current $b$ means the bias parameter for the current data. The values on the right side represent the size of the historical data. The values on the top of the plots represent the power prior weight parameter $a$. Blue means the credible interval for $b$ excludes zero. 

These plots indicate that our model can detect strong bias and bias ($b = \{-3, -2, 2,3\}$). When bias is moderate ($b = \{1, -1\}$), the model can detect it if the historical data has a bias parameter in the same direction. If the bias parameter of historical data is in an opposite direction, the model may provide a wrong estimate of current bias parameter. 

## Extension: Simultaneous Strikes

In some courts, both parties simultaneously exercise their peremptory challenges on the prospective jurors in a venire.  This may result in both sides using a strike each on the same potential juror. 

For any given case $i$ in which jury selection occurs and a party uses $s$ number of strikes under this process, @Barrett2007 models the probability of a party striking at least $x$ cognizable-class members at random as following a hypergeometric distribution:

$$Pr(X \geq x) = \sum_{x}^{s} \frac{{c_{i} \choose x} {m_{i} \choose s - x}}{{c_{i} + m_{i} \choose s}}$$

where $x = 0, 1, 2, 3, . . . s$; $c_{i}$ denotes the number of cognizable class members in the venire subject to strike; and $m_{i}$ denotes the number of cognizable class non-members in the venire subject to strike.

Here, we argue that a simultaneous-strikes process can be modeled as a special case of our model of an alternating-strikes process above, i.e, one party engages in an uninterrupted sequence of strikes against members of the venire. The premise: Regardless of the order in which a party announced those strikes, the posterior for the bias parameter would be the same.

To show this, we conducted the following simulation study. We first generate a trial and then shuffle the order of the strikes to generate 50 trials with the same proportion of struck cognizable class members but different orders. We then use the model to fit the 50 trials to see if the estimated bias parameter are close to each other. We conduct the simulation study under three scenarios from moderate bias to strong bias, that is $b=1,2,3$. The results are shown in figure \@ref(fig:simltns).

```{r simltns, fig.cap="simultaneous case", eval = FALSE}

#library(conflicted)
#conflict_prefer("select", "dplyr")
#conflict_prefer("filter", "dplyr")

# SCRIPT FOR GENERATING b1.csv, b2.csv, b3.csv

# generate data

source("R/simultaneous1.R")

# load already-generated data

load_path_b1 <- here::here("b1.csv")
load_path_b2 <- here::here("b2.csv")
load_path_b3 <- here::here("b3.csv")

b1 <- read.csv(load_path_b1)
b2 <- read.csv(load_path_b2)
b3 <- read.csv(load_path_b3)

b1.t <- b1 %>% select(-X) %>%
  t() %>% data.frame() %>% 
  dplyr::rename_with(~b1$X) %>%
      mutate(sim = as.character(1:50))
#b1.t$sim <- factor(b1.t$sim, levels = b1.t$sim, ordered = TRUE)

b2.t <- b2 %>% select(-X) %>%
  t() %>% data.frame() %>% 
  dplyr::rename_with(~b2$X) %>%
  mutate(sim =  as.character(1:50))
#b2.t$sim <- factor(b2.t$sim, levels = b2.t$sim, ordered = TRUE)

b3.t <- b3 %>% select(-X) %>%
  t() %>% data.frame() %>% 
  dplyr::rename_with(~b2$X) %>%
  mutate(sim = as.character(1:50))
#b3.t$sim <- factor(b3.t$sim, levels = b3.t$sim, ordered = TRUE)

colnames(b1.t)[1:3] = c('b_s','2.5%','97.5%')
colnames(b2.t)[1:3] = c('b_s','2.5%','97.5%')
colnames(b3.t)[1:3] = c('b_s','2.5%','97.5%')

b1.t$b = "1"
b2.t$b = "2"
b3.t$b = "3"
b.com <- rbind(b1.t, b2.t, b3.t)
b.com$sig <- ifelse(b.com$`2.5%`>0, "Bias", 
                                  "No Bias")
b.com$b.num <- as.numeric(b.com$b)

b1.mean <-data.frame(b_s = mean(b1.t$b_s), 
                     `2.5%` =  mean(b1.t$`2.5%`),
                     `97.5%` = mean(b1.t$`97.5%`),
                     sim = "mean", 
                     b = "1", 
                     sig = "No Bias", 
                     b.num = 1)
b2.mean <-data.frame(b_s = mean(b2.t$b_s), 
                     `2.5%` =  mean(b2.t$`2.5%`),
                     `97.5%` = mean(b2.t$`97.5%`),
                     sim = "mean", 
                     b = "2", 
                     sig = "Bias", 
                     b.num = 2)
b3.mean <-data.frame(b_s = mean(b3.t$b_s), 
                     `2.5%` =  mean(b3.t$`2.5%`),
                     `97.5%` = mean(b3.t$`97.5%`),
                     sim = "mean", 
                     b = "3", 
                     sig = "Bias", 
                     b.num = 3)


names(b1.mean)<- colnames(b.com)
names(b2.mean)<- colnames(b.com)
names(b3.mean)<- colnames(b.com)
b.com<- rbind(b.com,b1.mean[1,], b2.mean[1,], b3.mean[1,])
b.com$sim.n <- as.numeric(b.com$sim)
b.com$sim.n[151:153] <- 52.5

simplot <- ggplot(data = b.com, aes(x = sim.n, y = b_s, color = sig))+
  facet_grid(~b)+
  geom_point(size = 3)+
  geom_errorbar(aes(x = sim.n, ymin = `2.5%`, 
                    ymax = `97.5%`), width = 0.4)+
  geom_hline(data = b.com, aes(yintercept = b.num), col = "red", lwd = 1.1) +
  geom_hline(yintercept = 0, col = "black", lwd = 1, lty = 1) +
  geom_vline(xintercept = 51.25, col = "black", lwd = 1, lty = 2) +
  xlab("Simulation")+
  scale_color_manual("Bias", values = c("blue", "grey"))+
  ylab("Posterior Bias Value")+
  ylim(c(-0.5, 5))+
  scale_x_continuous(breaks = c(1:50, 52.5), labels = c(1:50, "Average"))+
  coord_flip()+
  theme_classic()+
  theme(axis.title = element_text(size = 16), 
        axis.text.x = element_text(size = 12), 
        axis.text.y = element_text(size = 9))

simplot

```

The points represent the estimated posterior mean and the lines represent the 95\% credible interval. The blue line means the credible interval does not include zero, thus indicating a bias, while the grey line means the credible interval includes zero and indicating no bias. We can find the estimated bias parameter of the 50 trials with different orders are close to each other for all of the three scenarios, indicating the order does not influence the estimate of the bias parameter. This confirms that the simultaneous-strikes process can be modeled as a special case of our model of an alternating-strikes process.

# The Software Prototype

We describe here a prototype software application ("app") that implements the approach described above. We built this app using `r R.version$version.string`[@R] and shiny [@shiny].  To demonstrate how this app might be used by lawyers in real cases, we loaded this app with real strike data from a convenience sample of attorneys who appeared during jury selection in criminal cases in the federal district court for Connecticut during fiscal years 2013 through 2017. 

To collect the data, one of us filed a request with the U.S. District Court of Connecticut based on 28 U.S.C. $\S$ 1868.  Thereafter, we received copies (pdf files) of certain jury-selection records associated with X trials in that court during this period. These included strike sheets that indicated the ID number of prospective jurors who were struck by peremptory challenge, the order in which they were struck, and which side (prosecutor or defense) struck which juror. Such records also included a tally of answers to juror questionnaires that asked each prospective juror to report their race and gender.

These records, however, often did not indicate the identity of the attorneys exercising the strikes. While the standard forms included a signature line for the attorney, many were left blank or filled with illegible signatures.  Accordingly, we turned to the publicly-available docket sheets for each case for the names of the lawyers who appeared in the case on behalf of the prosecution (the US Attorney's office) or the criminal defendant(s) on the date(s) of jury selection. Where only a single attorney represented a party during jury selection, it was easy to attribute the pattern of strikes to that attorney. Where multiple lawyers appeared for one side, we attributed to each of them that side's pattern of peremptory challenges in that case. In such cases, neither the jury-selection documents nor the docket sheets indicated any hierarchy among multiple lawyers or any other basis to attribute strikes to only one attorney among them. After generating a dataset based on these documents, we kept only strikes where a criminal defendant was represented by an attorney. Finally, to de-identify this dataset, we excluded defendant names and substituted fictitious names for the attorneys using the charlatan package [@charlatan].

With the app, the user uses the pull-down menus to select the cognizable class (top left) and enters by hand the strike information in the case before them in the _strike tally_ table (bottom left), either in real time or immediately after jury selection concludes. For demonstration purposes, the prototype app comes pre-loaded with a completed strike tally with values that can be changed and rows that can be added or deleted (Table \@ref(tab:inpts)). In the strike tally, `round` denotes the order of strikes, `num_cog` denotes the number of prospective jurors that could be struck that belong to the cognitive class; `total` denotes the total number of prospective jurors that could be struck; `cog` indicates whether the prosepective juror actually struck in that round was a member of the cognizable class (1 = yes, 0 = no); and `party` indicates which side used the strike (PP = prosecutor, PD = defense attorney).

```{r inpts, echo=FALSE}
df <- data.frame(round = c(1:10),
                 num_cog = c(4,4,4,3,2,2,2,2,2,2),
                 total = c(15,14,13,12,11,10,9,8,7,6),
                 cog = c(0,1,1,0,0,1,1,0,0,0),
                 party = rep(c("PP","PD"),5))
knitr::kable(df)

```

For the prototype app, we set two cognizable-class options: race and gender. This was simply because the historical data only contained information on prospective juror race and gender, itself a function of data collected as part of the standard juror questionnaire. The data did not expressly indicate the race or gender of the criminal defendant(s).

In the default setting, the pull-down menus for prosecutor and defense are set to "None". In that setting, the app ignores any historical strike data and estimates the posterior distributions of the bias parameter for prosecutor and defense based only on the strike tally data and the initial prior ($b = N(0,2)$). The main screen accordingly displays two graphs -- one for the prosecution and the defense - that each depict the prior and posterior density plots for the bias parameter. 

To use historical strike data, the user selects a name of the prosecutor or defense attorney from the pull-down menus. If an attorney's name cannot be found, the app has no historical strike data for that attorney. Once selected, the prior density plot (colored grey) and the posterior density plot (blue and red for defense and prosecution, respectively) automatically updates to account for the pre-loaded historical strike data for that attorney. For the weight to assign that attorney's historical strike data, the default is set to equal weight of historical information and current information ($a = 1$). The user has two other options: half weight of historical information ($a = 0.5$) and low weight of historical information ($a = 0.2$).

To illustrate, suppose the strike tally in Table \@ref(tab:inpts) represents the pattern of strikes in the present case with prosecutor "X" and defense attorney "Y". To detect racial bias in the use of peremptory strikes using both the strike tally and historical strike data, we set the cognizable-class to "Race"; select the names of the prosecutor and defense attorney from their respective pull-down menus; and set the weight setting to "Equal". The app will in turn display the posterior density plots in Figure \@ref(fig:brian). 

```{r brian, fig.cap="Posterior Density Plot, a = 1, cognizable class = race"}
library(dplyr)
library(Rcpp)
load_path2 <- here::here("app/mh_sampler_pp.cpp")
load_path3 <- here::here("app/jury_data_cleaned_new.rds")
sourceCpp(load_path2)
sourceCpp(load_path2)
dat0 <- readRDS(load_path3)
df <- data.frame(round = c(1:10),
                 num_cog = c(4,4,4,3,2,2,2,2,2,2),
                 total = c(15,14,13,12,11,10,9,8,7,6),
                 cog = c(0,1,1,0,0,1,1,0,0,0),
                 party = rep(c("PP","PD"),5))
extract_atny <- function(atny_name,pp,dat){
  if(pp){
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$P_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
  else{
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$D_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
} 
organize_input <- function(dat,pp,cog){
  dat_strikes <- dat %>% filter(!is.na(strike_seq)) 
  if(cog=='gender'){
    dat_strikes <- dat_strikes %>% filter(!is.na(sex))
  }else{
    dat_strikes <- dat_strikes %>% filter(!is.na(race))
  }
  
  dat_strikes <- dat_strikes[order(dat_strikes$strike_seq),]
  if(cog=='gender'){
    dat_strikes$cogb <- ifelse(dat_strikes$sex=="F", 1, 0)
  }else{
    dat_strikes$cogb <- ifelse(dat_strikes$race !=3, 1, 0)
  }
  
  num_cog <- sum(dat_strikes$cogb)
  num_t <- nrow(dat_strikes)
  subs <- data.frame(round = c(1:num_t), 
                     num_cog = NA, 
                     total = NA)
  subs$num_cog[1] <- num_cog
  subs$total[1] <- num_t
  for ( j in 2:num_t){
    num_cog = num_cog-dat_strikes$cogb[j-1]
    num_total = num_t - dat_strikes$strike_seq[j-1]
    subs$num_cog[j] <- num_cog
    # number of females struck in this and previous rounds
    subs$total[j] <- num_total
  }
  subs <- cbind(subs,dat_strikes$cogb)
  colnames(subs)[4] = 'cognizable'
  if(pp){
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PP'),])
  }else{
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PD'),])
  }
  return(df_m)
}
subset <- function(atny_name,pp,dat,cog){
  dat_sub <- extract_atny(atny_name,pp,dat)
  sub1 <- dat_sub %>% group_split(ID)
  sub1_l <- lapply(1:length(sub1), function(x) organize_input(sub1[[x]],pp,cog))
  df_m = do.call(rbind.data.frame,sub1_l)
  df_m <- as.matrix(df_m)
}
df_mp <- df %>%
                filter(party == "PP") %>%
                select(-c(party)) %>%
                as.matrix()

df_md <- df %>%
                filter(party == "PD") %>%
                select(-c(party)) %>%
                as.matrix()

sub_p <- subset("Brian P. Leaming",TRUE,dat0,"race")
sub_d <- subset("Frank J. Riccio II",FALSE,dat0,"race")
out_p <- make_posterior_p(x = df_mp,x_p =sub_p,a0 = 1, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pp_prior_theta <- make_posterior_prior(x_p=sub_p,a0 = 1, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                                       prior_mean = 0, prior_sd = 2)
d_p <- data.frame(
                theta = out_p$theta[10001:110000],
                party = "Prosecution", 
                posterior = "Posterior")
pp_prior <- data.frame(theta = pp_prior_theta$theta[10001:110000], 
                                       party = "Prosecution", 
                                       posterior = "Prior")

out_d <- make_posterior_p(x = df_md,x_p = sub_d,a0= 1, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pd_prior_theta <- make_posterior_prior(x_p=sub_d,a0 = 1, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                        prior_mean = 0, prior_sd = 2)
pd_prior <- data.frame(theta = pd_prior_theta$theta[10001:110000], 
                                       party = "Defense", 
                                       posterior = "Prior")
d_d <- data.frame(
                theta = out_d$theta[10001:110000],
                party = "Defense", 
                posterior = "Posterior")

dat <- rbind(d_p,d_d)
priors <- rbind(pp_prior, pd_prior)
dat <- rbind(dat, priors)
dat$party <- factor(dat$party, levels = c("Defense", "Prosecution"), 
                                ordered = TRUE)
CI <- dat %>% filter(posterior == 'Posterior') %>%
                group_by(party) %>%
                summarise(q1 = quantile(theta,0.1), q2 = quantile(theta,0.9)) %>%
                mutate(bias = ifelse(
                    q1 <= 0 & q2 >= 0, "No Bias", "Bias"))
pplot <- ggplot(data=dat) + 
                geom_density(aes(x = theta, 
                                 fill = interaction(party, posterior),
                                 color = interaction(party, posterior),
                                 alpha = interaction(party, posterior), 
                                 ..scaled..))+
                facet_wrap(~party, nrow =2)

pplot <- pplot  + theme_minimal() +
                 labs (title = "Likely values of b") +
                 xlab("") + 
                 ylab("") + 
                 xlim(c(-6,6)) +
                 scale_fill_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_color_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_alpha_manual("Group", values = c(0.3, 0.3, 0.1, 0.1)) +
                
                  # edit text sizes for plot
                 theme(legend.position="none",
                       axis.text = element_text(size = 16), 
                       strip.text = element_text(size = 18), 
                       plot.title = element_text(size = 24),
                       plot.subtitle = element_text(size = 16)) +
                  # add line at zero for reference
                 geom_vline(xintercept = 0, color = "black", lwd=1.5)

 pplot + geom_vline(data=CI, aes(xintercept=q1), color = c("blue", "darkred"),
                               linetype="dashed", size = 0.9)+
                    geom_vline(data=CI, aes(xintercept=q2), color = c("blue", "darkred"),
                           linetype="dashed", size = 0.9) 
 
```

The grey curve represents the probability density of the prior, the blue curve represents the posterior probability density of the defense attorney and the red curve represents the posterior probability density of the prosecutor. The two vertical dotted lines depict the 80\% credible interval.  Most of both the prior and posterior density curve are on the right side of zero, and the 80\% credible interval is also on the right side of zero. Thus, we have a credible basis to infer bias against racial-minority prospective jurors in how these attorney use their peremptory challenges in the present case. 

Now suppose that the strike tally indicates the pattern of strikes by these attorneys against women. If so, we can select "gender" as the cognizable class, and the density plots becomes Figure \@ref(fig:brian2).

```{r brian2, fig.cap="Posterior Density Plots, a = 1, cognitive class = gender"}

load_path2 <- here::here("app/mh_sampler_pp.cpp")
load_path3 <- here::here("app/jury_data_cleaned_new.rds")

sourceCpp(load_path2)

dat0 <- readRDS(load_path3)

df <- data.frame(round = c(1:10),
                 num_cog = c(4,4,4,3,2,2,2,2,2,2),
                 total = c(15,14,13,12,11,10,9,8,7,6),
                 cog = c(0,1,1,0,0,1,1,0,0,0),
                 party = rep(c("PP","PD"),5))

extract_atny <- function(atny_name,pp,dat){
  if(pp){
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$P_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
  else{
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$D_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
} 
organize_input <- function(dat,pp,cog){
  dat_strikes <- dat %>% filter(!is.na(strike_seq)) 
  if(cog=='gender'){
    dat_strikes <- dat_strikes %>% filter(!is.na(sex))
  }else{
    dat_strikes <- dat_strikes %>% filter(!is.na(race))
  }
  
  dat_strikes <- dat_strikes[order(dat_strikes$strike_seq),]
  if(cog=='gender'){
    dat_strikes$cogb <- ifelse(dat_strikes$sex=="F", 1, 0)
  }else{
    dat_strikes$cogb <- ifelse(dat_strikes$race !=3, 1, 0)
  }
  
  num_cog <- sum(dat_strikes$cogb)
  num_t <- nrow(dat_strikes)
  subs <- data.frame(round = c(1:num_t), 
                     num_cog = NA, 
                     total = NA)
  subs$num_cog[1] <- num_cog
  subs$total[1] <- num_t
  for ( j in 2:num_t){
    num_cog = num_cog-dat_strikes$cogb[j-1]
    num_total = num_t - dat_strikes$strike_seq[j-1]
    subs$num_cog[j] <- num_cog
    # number of females struck in this and previous rounds
    subs$total[j] <- num_total
  }
  subs <- cbind(subs,dat_strikes$cogb)
  colnames(subs)[4] = 'cognizable'
  if(pp){
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PP'),])
  }else{
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PD'),])
  }
  return(df_m)
}
subset <- function(atny_name,pp,dat,cog){
  dat_sub <- extract_atny(atny_name,pp,dat)
  sub1 <- dat_sub %>% group_split(ID)
  sub1_l <- lapply(1:length(sub1), function(x) organize_input(sub1[[x]],pp,cog))
  df_m = do.call(rbind.data.frame,sub1_l)
  df_m <- as.matrix(df_m)
}
df_mp <- df %>%
                filter(party == "PP") %>%
                select(-c(party)) %>%
                as.matrix()

df_md <- df %>%
                filter(party == "PD") %>%
                select(-c(party)) %>%
                as.matrix()

sub_p <- subset("Brian P. Leaming",TRUE,dat0,"gender")
sub_d <- subset("Frank J. Riccio II",FALSE,dat0,"gender")
out_p <- make_posterior_p(x = df_mp,x_p =sub_p,a0 = 1, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pp_prior_theta <- make_posterior_prior(x_p=sub_p,a0 = 1, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                                       prior_mean = 0, prior_sd = 2)
d_p <- data.frame(
                theta = out_p$theta[10001:110000],
                party = "Prosecution", 
                posterior = "Posterior")
pp_prior <- data.frame(theta = pp_prior_theta$theta[10001:110000], 
                                       party = "Prosecution", 
                                       posterior = "Prior")

out_d <- make_posterior_p(x = df_md,x_p = sub_d,a0= 1, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pd_prior_theta <- make_posterior_prior(x_p=sub_d,a0 = 1, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                        prior_mean = 0, prior_sd = 2)
pd_prior <- data.frame(theta = pd_prior_theta$theta[10001:110000], 
                                       party = "Defense", 
                                       posterior = "Prior")
d_d <- data.frame(
                theta = out_d$theta[10001:110000],
                party = "Defense", 
                posterior = "Posterior")

dat <- rbind(d_p,d_d)
priors <- rbind(pp_prior, pd_prior)
dat <- rbind(dat, priors)
dat$party <- factor(dat$party, levels = c("Defense", "Prosecution"), 
                                ordered = TRUE)
CI <- dat %>% filter(posterior == 'Posterior') %>%
                group_by(party) %>%
                summarise(q1 = quantile(theta,0.1), q2 = quantile(theta,0.9)) %>%
                mutate(bias = ifelse(
                    q1 <= 0 & q2 >= 0, "No Bias", "Bias"))
pplot <- ggplot(data=dat) + 
                geom_density(aes(x = theta, 
                                 fill = interaction(party, posterior),
                                 color = interaction(party, posterior),
                                 alpha = interaction(party, posterior), 
                                 ..scaled..))+
                facet_wrap(~party, nrow =2)

pplot <- pplot  + theme_minimal() +
                 labs (title = "Likely values of b") +
                 xlab("") + 
                 ylab("") + 
                 xlim(c(-6,6)) +
                 scale_fill_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_color_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_alpha_manual("Group", values = c(0.3, 0.3, 0.1, 0.1)) +
                
                  # edit text sizes for plot
                 theme(legend.position="none",
                       axis.text = element_text(size = 16), 
                       strip.text = element_text(size = 18), 
                       plot.title = element_text(size = 24),
                       plot.subtitle = element_text(size = 16)) +
                  # add line at zero for reference
                 geom_vline(xintercept = 0, color = "black", lwd=1.5)

 pplot + geom_vline(data=CI, aes(xintercept=q1), color = c("blue", "darkred"),
                               linetype="dashed", size = 0.9)+
                    geom_vline(data=CI, aes(xintercept=q2), color = c("blue", "darkred"),
                           linetype="dashed", size = 0.9) 
```

Here, most of the density curve of both prior and posterior are on the left of zero, indicating the possible bias against male jurors. However, since the 80\% credible interval includes 0, inferring that preference from the strike data alone is unjustified. 

Finally, if we give low weight on historical information, the density plot will be as shown in figure \@ref(fig:brian3).

```{r brian3, echo=FALSE,fig.cap="Posterior Density Plot, a = 0.2"}
load_path2 <- here::here("app/mh_sampler_pp.cpp")
load_path3 <- here::here("app/jury_data_cleaned_new.rds")
sourceCpp(load_path2)
sourceCpp(load_path2)
dat0 <- readRDS(load_path3)
df <- data.frame(round = c(1:10),
                 num_cog = c(4,4,4,3,2,2,2,2,2,2),
                 total = c(15,14,13,12,11,10,9,8,7,6),
                 cog = c(0,1,1,0,0,1,1,0,0,0),
                 party = rep(c("PP","PD"),5))
extract_atny <- function(atny_name,pp,dat){
  if(pp){
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$P_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
  else{
    idx = sapply(1:nrow(dat),function(x) grepl(atny_name, dat$D_atty_l[x], fixed=TRUE))
    return(dat[which(idx),])
  }
} 
organize_input <- function(dat,pp,cog){
  dat_strikes <- dat %>% filter(!is.na(strike_seq)) 
  if(cog=='gender'){
    dat_strikes <- dat_strikes %>% filter(!is.na(sex))
  }else{
    dat_strikes <- dat_strikes %>% filter(!is.na(race))
  }
  
  dat_strikes <- dat_strikes[order(dat_strikes$strike_seq),]
  if(cog=='gender'){
    dat_strikes$cogb <- ifelse(dat_strikes$sex=="F", 1, 0)
  }else{
    dat_strikes$cogb <- ifelse(dat_strikes$race !=3, 1, 0)
  }
  
  num_cog <- sum(dat_strikes$cogb)
  num_t <- nrow(dat_strikes)
  subs <- data.frame(round = c(1:num_t), 
                     num_cog = NA, 
                     total = NA)
  subs$num_cog[1] <- num_cog
  subs$total[1] <- num_t
  for ( j in 2:num_t){
    num_cog = num_cog-dat_strikes$cogb[j-1]
    num_total = num_t - dat_strikes$strike_seq[j-1]
    subs$num_cog[j] <- num_cog
    # number of females struck in this and previous rounds
    subs$total[j] <- num_total
  }
  subs <- cbind(subs,dat_strikes$cogb)
  colnames(subs)[4] = 'cognizable'
  if(pp){
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PP'),])
  }else{
    df_m <- as.matrix(subs[which(dat_strikes$Disp=='PD'),])
  }
  return(df_m)
}
subset <- function(atny_name,pp,dat,cog){
  dat_sub <- extract_atny(atny_name,pp,dat)
  sub1 <- dat_sub %>% group_split(ID)
  sub1_l <- lapply(1:length(sub1), function(x) organize_input(sub1[[x]],pp,cog))
  df_m = do.call(rbind.data.frame,sub1_l)
  df_m <- as.matrix(df_m)
}
df_mp <- df %>%
                filter(party == "PP") %>%
                select(-c(party)) %>%
                as.matrix()

df_md <- df %>%
                filter(party == "PD") %>%
                select(-c(party)) %>%
                as.matrix()

sub_p <- subset("Brian P. Leaming",TRUE,dat0,"gender")
sub_d <- subset("Frank J. Riccio II",FALSE,dat0,"gender")
out_p <- make_posterior_p(x = df_mp,x_p =sub_p,a0 = 0.2, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pp_prior_theta <- make_posterior_prior(x_p=sub_p,a0 = 0.2, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                                       prior_mean = 0, prior_sd = 2)
d_p <- data.frame(
                theta = out_p$theta[10001:110000],
                party = "Prosecution", 
                posterior = "Posterior")
pp_prior <- data.frame(theta = pp_prior_theta$theta[10001:110000], 
                                       party = "Prosecution", 
                                       posterior = "Prior")

out_d <- make_posterior_p(x = df_md,x_p = sub_d,a0= 0.2, niter = 110000, 
                                          theta_start_val = 0, theta_proposal_sd =.5, 
                                          prior_mean = 0, prior_sd = 2)
pd_prior_theta <- make_posterior_prior(x_p=sub_d,a0 = 0.2, niter = 110000, 
                                        theta_start_val = 0, theta_proposal_sd =.5, 
                                        prior_mean = 0, prior_sd = 2)
pd_prior <- data.frame(theta = pd_prior_theta$theta[10001:110000], 
                                       party = "Defense", 
                                       posterior = "Prior")
d_d <- data.frame(
                theta = out_d$theta[10001:110000],
                party = "Defense", 
                posterior = "Posterior")

dat <- rbind(d_p,d_d)
priors <- rbind(pp_prior, pd_prior)
dat <- rbind(dat, priors)
dat$party <- factor(dat$party, levels = c("Defense", "Prosecution"), 
                                ordered = TRUE)
CI <- dat %>% filter(posterior == 'Posterior') %>%
                group_by(party) %>%
                summarise(q1 = quantile(theta,0.1), q2 = quantile(theta,0.9)) %>%
                mutate(bias = ifelse(
                    q1 <= 0 & q2 >= 0, "No Bias", "Bias"))
pplot <- ggplot(data=dat) + 
                geom_density(aes(x = theta, 
                                 fill = interaction(party, posterior),
                                 color = interaction(party, posterior),
                                 alpha = interaction(party, posterior), 
                                 ..scaled..))+
                facet_wrap(~party, nrow =2)

pplot <- pplot  + theme_minimal() +
                 labs (title = "Likely values of b") +
                 xlab("") + 
                 ylab("") + 
                 xlim(c(-6,6)) +
                 scale_fill_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_color_manual("Group", values = c("blue", "darkred", "grey", "grey")) +
                 scale_alpha_manual("Group", values = c(0.3, 0.3, 0.1, 0.1)) +
                
                  # edit text sizes for plot
                 theme(legend.position="none",
                       axis.text = element_text(size = 16), 
                       strip.text = element_text(size = 18), 
                       plot.title = element_text(size = 24),
                       plot.subtitle = element_text(size = 16)) +
                  # add line at zero for reference
                 geom_vline(xintercept = 0, color = "black", lwd=1.5)

 pplot + geom_vline(data=CI, aes(xintercept=q1), color = c("blue", "darkred"),
                               linetype="dashed", size = 0.9)+
                    geom_vline(data=CI, aes(xintercept=q2), color = c("blue", "darkred"),
                           linetype="dashed", size = 0.9) 
```

We can find both the prior and posterior density become more flat, and the posterior density appears symmetric around zero now.

# Discussion

In a typical _Batson_ challenge, the challenging party must typically establish a "prima facie case", that is, enough evidence to infer that a party struck a juror because of such juror's race, gender, or other protected status. If so, the burden shifts to the challenged party to produce one or more nondiscriminatory reasons for that strike. Thereafter, the challenger must persuade the trial judge that prospective jurors' race or gender, not the proffered nondiscriminatory reason(s), was more likely than not the real motivation for the challenged strike(s) [@LaFave2020, sec. 22.3]. 

Despite _Batson_ and its progeny, "prosecutors in criminal cases, and defense attorneys in civil case are more likely to use their challenges to dismiss African American jurors, whereas criminal defense attorneys and civil plaintiff's attorneys are more likely to exercise their strikes on white prospective jurors." [@Diamond2018]. Possible explanations include attorney fear that even raising a _Batson_ challenge raises with it the embarrassment and discomfort associated with accusing another attorney of being racist [@OBrien2019, 29; @Offit2021]. Similarly, a trial judge deciding a _Batson_ challenge may similarly be reluctant to find against opposing counsel, particularly if that prosecutor repeatedly appears before that judge.

One virtue of incorporating the power prior: Strike data on past trials may be missing information not at random [e.g., @Baldus2001, 132-134]. Possible reasons include that some jurisdictions do not require recording relevant or detailed enough information about jurors who were or could have been struck (e.g., their race or gender), thus forcing lawyers and researchers to turn to other data sources (e.g., voter registration rolls), if any, to find that information. Finally, judges and court staff vary in how often they fully complete or maintain the information they are required to record.

## Costs and Benefits of Bayesian Approach



# Conclusion


# CRediT Author Statement

Sachin S. Pandya: Conceptualization, Investigation, Software, Writing; Xiaomeng Li: Conceptualization, Formal Analysis, Software, Writing - original draft; Timothy Moore: Conceptualization, Supervision, Visualization. Based on categories in https://casrai.org/credit/].

# References
